// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'coin_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$CoinEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CoinEventCopyWith<$Res> {
  factory $CoinEventCopyWith(CoinEvent value, $Res Function(CoinEvent) then) =
      _$CoinEventCopyWithImpl<$Res, CoinEvent>;
}

/// @nodoc
class _$CoinEventCopyWithImpl<$Res, $Val extends CoinEvent>
    implements $CoinEventCopyWith<$Res> {
  _$CoinEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CoinEventImplCopyWith<$Res> {
  factory _$$CoinEventImplCopyWith(
          _$CoinEventImpl value, $Res Function(_$CoinEventImpl) then) =
      __$$CoinEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CoinEventImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$CoinEventImpl>
    implements _$$CoinEventImplCopyWith<$Res> {
  __$$CoinEventImplCopyWithImpl(
      _$CoinEventImpl _value, $Res Function(_$CoinEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$CoinEventImpl implements _CoinEvent {
  const _$CoinEventImpl();

  @override
  String toString() {
    return 'CoinEvent()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CoinEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class _CoinEvent implements CoinEvent {
  const factory _CoinEvent() = _$CoinEventImpl;
}

/// @nodoc
abstract class _$$FetchCoinsImplCopyWith<$Res> {
  factory _$$FetchCoinsImplCopyWith(
          _$FetchCoinsImpl value, $Res Function(_$FetchCoinsImpl) then) =
      __$$FetchCoinsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchCoinsImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$FetchCoinsImpl>
    implements _$$FetchCoinsImplCopyWith<$Res> {
  __$$FetchCoinsImplCopyWithImpl(
      _$FetchCoinsImpl _value, $Res Function(_$FetchCoinsImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FetchCoinsImpl implements _FetchCoins {
  const _$FetchCoinsImpl();

  @override
  String toString() {
    return 'CoinEvent.fetchCoins()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FetchCoinsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return fetchCoins();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return fetchCoins?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoins != null) {
      return fetchCoins();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return fetchCoins(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return fetchCoins?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoins != null) {
      return fetchCoins(this);
    }
    return orElse();
  }
}

abstract class _FetchCoins implements CoinEvent {
  const factory _FetchCoins() = _$FetchCoinsImpl;
}

/// @nodoc
abstract class _$$UpdateCoinListImplCopyWith<$Res> {
  factory _$$UpdateCoinListImplCopyWith(_$UpdateCoinListImpl value,
          $Res Function(_$UpdateCoinListImpl) then) =
      __$$UpdateCoinListImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Coin coins});
}

/// @nodoc
class __$$UpdateCoinListImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$UpdateCoinListImpl>
    implements _$$UpdateCoinListImplCopyWith<$Res> {
  __$$UpdateCoinListImplCopyWithImpl(
      _$UpdateCoinListImpl _value, $Res Function(_$UpdateCoinListImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coins = null,
  }) {
    return _then(_$UpdateCoinListImpl(
      null == coins
          ? _value.coins
          : coins // ignore: cast_nullable_to_non_nullable
              as Coin,
    ));
  }
}

/// @nodoc

class _$UpdateCoinListImpl implements _UpdateCoinList {
  const _$UpdateCoinListImpl(this.coins);

  @override
  final Coin coins;

  @override
  String toString() {
    return 'CoinEvent.updateCoinList(coins: $coins)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateCoinListImpl &&
            (identical(other.coins, coins) || other.coins == coins));
  }

  @override
  int get hashCode => Object.hash(runtimeType, coins);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateCoinListImplCopyWith<_$UpdateCoinListImpl> get copyWith =>
      __$$UpdateCoinListImplCopyWithImpl<_$UpdateCoinListImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return updateCoinList(coins);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return updateCoinList?.call(coins);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (updateCoinList != null) {
      return updateCoinList(coins);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return updateCoinList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return updateCoinList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (updateCoinList != null) {
      return updateCoinList(this);
    }
    return orElse();
  }
}

abstract class _UpdateCoinList implements CoinEvent {
  const factory _UpdateCoinList(final Coin coins) = _$UpdateCoinListImpl;

  Coin get coins;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateCoinListImplCopyWith<_$UpdateCoinListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchCoinSuccessImplCopyWith<$Res> {
  factory _$$FetchCoinSuccessImplCopyWith(_$FetchCoinSuccessImpl value,
          $Res Function(_$FetchCoinSuccessImpl) then) =
      __$$FetchCoinSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Coin> coins});
}

/// @nodoc
class __$$FetchCoinSuccessImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$FetchCoinSuccessImpl>
    implements _$$FetchCoinSuccessImplCopyWith<$Res> {
  __$$FetchCoinSuccessImplCopyWithImpl(_$FetchCoinSuccessImpl _value,
      $Res Function(_$FetchCoinSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coins = null,
  }) {
    return _then(_$FetchCoinSuccessImpl(
      null == coins
          ? _value._coins
          : coins // ignore: cast_nullable_to_non_nullable
              as List<Coin>,
    ));
  }
}

/// @nodoc

class _$FetchCoinSuccessImpl implements _FetchCoinSuccess {
  const _$FetchCoinSuccessImpl(final List<Coin> coins) : _coins = coins;

  final List<Coin> _coins;
  @override
  List<Coin> get coins {
    if (_coins is EqualUnmodifiableListView) return _coins;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_coins);
  }

  @override
  String toString() {
    return 'CoinEvent.fetchCoinSuccess(coins: $coins)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchCoinSuccessImpl &&
            const DeepCollectionEquality().equals(other._coins, _coins));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_coins));

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchCoinSuccessImplCopyWith<_$FetchCoinSuccessImpl> get copyWith =>
      __$$FetchCoinSuccessImplCopyWithImpl<_$FetchCoinSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return fetchCoinSuccess(coins);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return fetchCoinSuccess?.call(coins);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoinSuccess != null) {
      return fetchCoinSuccess(coins);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return fetchCoinSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return fetchCoinSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoinSuccess != null) {
      return fetchCoinSuccess(this);
    }
    return orElse();
  }
}

abstract class _FetchCoinSuccess implements CoinEvent {
  const factory _FetchCoinSuccess(final List<Coin> coins) =
      _$FetchCoinSuccessImpl;

  List<Coin> get coins;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FetchCoinSuccessImplCopyWith<_$FetchCoinSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchCoinFailureImplCopyWith<$Res> {
  factory _$$FetchCoinFailureImplCopyWith(_$FetchCoinFailureImpl value,
          $Res Function(_$FetchCoinFailureImpl) then) =
      __$$FetchCoinFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? errorMessage});
}

/// @nodoc
class __$$FetchCoinFailureImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$FetchCoinFailureImpl>
    implements _$$FetchCoinFailureImplCopyWith<$Res> {
  __$$FetchCoinFailureImplCopyWithImpl(_$FetchCoinFailureImpl _value,
      $Res Function(_$FetchCoinFailureImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? errorMessage = freezed,
  }) {
    return _then(_$FetchCoinFailureImpl(
      freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$FetchCoinFailureImpl implements _FetchCoinFailure {
  const _$FetchCoinFailureImpl([this.errorMessage]);

  @override
  final String? errorMessage;

  @override
  String toString() {
    return 'CoinEvent.fetchCoinFailure(errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchCoinFailureImpl &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, errorMessage);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchCoinFailureImplCopyWith<_$FetchCoinFailureImpl> get copyWith =>
      __$$FetchCoinFailureImplCopyWithImpl<_$FetchCoinFailureImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return fetchCoinFailure(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return fetchCoinFailure?.call(errorMessage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoinFailure != null) {
      return fetchCoinFailure(errorMessage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return fetchCoinFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return fetchCoinFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (fetchCoinFailure != null) {
      return fetchCoinFailure(this);
    }
    return orElse();
  }
}

abstract class _FetchCoinFailure implements CoinEvent {
  const factory _FetchCoinFailure([final String? errorMessage]) =
      _$FetchCoinFailureImpl;

  String? get errorMessage;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FetchCoinFailureImplCopyWith<_$FetchCoinFailureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SearchCryptoImplCopyWith<$Res> {
  factory _$$SearchCryptoImplCopyWith(
          _$SearchCryptoImpl value, $Res Function(_$SearchCryptoImpl) then) =
      __$$SearchCryptoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String cryptoSearchString});
}

/// @nodoc
class __$$SearchCryptoImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$SearchCryptoImpl>
    implements _$$SearchCryptoImplCopyWith<$Res> {
  __$$SearchCryptoImplCopyWithImpl(
      _$SearchCryptoImpl _value, $Res Function(_$SearchCryptoImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cryptoSearchString = null,
  }) {
    return _then(_$SearchCryptoImpl(
      null == cryptoSearchString
          ? _value.cryptoSearchString
          : cryptoSearchString // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SearchCryptoImpl implements _SearchCrypto {
  const _$SearchCryptoImpl(this.cryptoSearchString);

  @override
  final String cryptoSearchString;

  @override
  String toString() {
    return 'CoinEvent.searchCrypto(cryptoSearchString: $cryptoSearchString)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SearchCryptoImpl &&
            (identical(other.cryptoSearchString, cryptoSearchString) ||
                other.cryptoSearchString == cryptoSearchString));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cryptoSearchString);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SearchCryptoImplCopyWith<_$SearchCryptoImpl> get copyWith =>
      __$$SearchCryptoImplCopyWithImpl<_$SearchCryptoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return searchCrypto(cryptoSearchString);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return searchCrypto?.call(cryptoSearchString);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (searchCrypto != null) {
      return searchCrypto(cryptoSearchString);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return searchCrypto(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return searchCrypto?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (searchCrypto != null) {
      return searchCrypto(this);
    }
    return orElse();
  }
}

abstract class _SearchCrypto implements CoinEvent {
  const factory _SearchCrypto(final String cryptoSearchString) =
      _$SearchCryptoImpl;

  String get cryptoSearchString;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SearchCryptoImplCopyWith<_$SearchCryptoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CryptoSearchStringChangedImplCopyWith<$Res> {
  factory _$$CryptoSearchStringChangedImplCopyWith(
          _$CryptoSearchStringChangedImpl value,
          $Res Function(_$CryptoSearchStringChangedImpl) then) =
      __$$CryptoSearchStringChangedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String cryptoSearchString});
}

/// @nodoc
class __$$CryptoSearchStringChangedImplCopyWithImpl<$Res>
    extends _$CoinEventCopyWithImpl<$Res, _$CryptoSearchStringChangedImpl>
    implements _$$CryptoSearchStringChangedImplCopyWith<$Res> {
  __$$CryptoSearchStringChangedImplCopyWithImpl(
      _$CryptoSearchStringChangedImpl _value,
      $Res Function(_$CryptoSearchStringChangedImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cryptoSearchString = null,
  }) {
    return _then(_$CryptoSearchStringChangedImpl(
      null == cryptoSearchString
          ? _value.cryptoSearchString
          : cryptoSearchString // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CryptoSearchStringChangedImpl implements _CryptoSearchStringChanged {
  const _$CryptoSearchStringChangedImpl(this.cryptoSearchString);

  @override
  final String cryptoSearchString;

  @override
  String toString() {
    return 'CoinEvent.cryptoSearchStringChanged(cryptoSearchString: $cryptoSearchString)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CryptoSearchStringChangedImpl &&
            (identical(other.cryptoSearchString, cryptoSearchString) ||
                other.cryptoSearchString == cryptoSearchString));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cryptoSearchString);

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CryptoSearchStringChangedImplCopyWith<_$CryptoSearchStringChangedImpl>
      get copyWith => __$$CryptoSearchStringChangedImplCopyWithImpl<
          _$CryptoSearchStringChangedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function() fetchCoins,
    required TResult Function(Coin coins) updateCoinList,
    required TResult Function(List<Coin> coins) fetchCoinSuccess,
    required TResult Function(String? errorMessage) fetchCoinFailure,
    required TResult Function(String cryptoSearchString) searchCrypto,
    required TResult Function(String cryptoSearchString)
        cryptoSearchStringChanged,
  }) {
    return cryptoSearchStringChanged(cryptoSearchString);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? fetchCoins,
    TResult? Function(Coin coins)? updateCoinList,
    TResult? Function(List<Coin> coins)? fetchCoinSuccess,
    TResult? Function(String? errorMessage)? fetchCoinFailure,
    TResult? Function(String cryptoSearchString)? searchCrypto,
    TResult? Function(String cryptoSearchString)? cryptoSearchStringChanged,
  }) {
    return cryptoSearchStringChanged?.call(cryptoSearchString);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? fetchCoins,
    TResult Function(Coin coins)? updateCoinList,
    TResult Function(List<Coin> coins)? fetchCoinSuccess,
    TResult Function(String? errorMessage)? fetchCoinFailure,
    TResult Function(String cryptoSearchString)? searchCrypto,
    TResult Function(String cryptoSearchString)? cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (cryptoSearchStringChanged != null) {
      return cryptoSearchStringChanged(cryptoSearchString);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_CoinEvent value) $default, {
    required TResult Function(_FetchCoins value) fetchCoins,
    required TResult Function(_UpdateCoinList value) updateCoinList,
    required TResult Function(_FetchCoinSuccess value) fetchCoinSuccess,
    required TResult Function(_FetchCoinFailure value) fetchCoinFailure,
    required TResult Function(_SearchCrypto value) searchCrypto,
    required TResult Function(_CryptoSearchStringChanged value)
        cryptoSearchStringChanged,
  }) {
    return cryptoSearchStringChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_CoinEvent value)? $default, {
    TResult? Function(_FetchCoins value)? fetchCoins,
    TResult? Function(_UpdateCoinList value)? updateCoinList,
    TResult? Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult? Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult? Function(_SearchCrypto value)? searchCrypto,
    TResult? Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
  }) {
    return cryptoSearchStringChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_CoinEvent value)? $default, {
    TResult Function(_FetchCoins value)? fetchCoins,
    TResult Function(_UpdateCoinList value)? updateCoinList,
    TResult Function(_FetchCoinSuccess value)? fetchCoinSuccess,
    TResult Function(_FetchCoinFailure value)? fetchCoinFailure,
    TResult Function(_SearchCrypto value)? searchCrypto,
    TResult Function(_CryptoSearchStringChanged value)?
        cryptoSearchStringChanged,
    required TResult orElse(),
  }) {
    if (cryptoSearchStringChanged != null) {
      return cryptoSearchStringChanged(this);
    }
    return orElse();
  }
}

abstract class _CryptoSearchStringChanged implements CoinEvent {
  const factory _CryptoSearchStringChanged(final String cryptoSearchString) =
      _$CryptoSearchStringChangedImpl;

  String get cryptoSearchString;

  /// Create a copy of CoinEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CryptoSearchStringChangedImplCopyWith<_$CryptoSearchStringChangedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CoinState {
  FormzSubmissionStatus get getCoinStatus => throw _privateConstructorUsedError;
  List<Coin>? get coinList => throw _privateConstructorUsedError;
  String? get errorMessage => throw _privateConstructorUsedError;
  String? get cryptoSearchString => throw _privateConstructorUsedError;

  /// Create a copy of CoinState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CoinStateCopyWith<CoinState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CoinStateCopyWith<$Res> {
  factory $CoinStateCopyWith(CoinState value, $Res Function(CoinState) then) =
      _$CoinStateCopyWithImpl<$Res, CoinState>;
  @useResult
  $Res call(
      {FormzSubmissionStatus getCoinStatus,
      List<Coin>? coinList,
      String? errorMessage,
      String? cryptoSearchString});
}

/// @nodoc
class _$CoinStateCopyWithImpl<$Res, $Val extends CoinState>
    implements $CoinStateCopyWith<$Res> {
  _$CoinStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CoinState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? getCoinStatus = null,
    Object? coinList = freezed,
    Object? errorMessage = freezed,
    Object? cryptoSearchString = freezed,
  }) {
    return _then(_value.copyWith(
      getCoinStatus: null == getCoinStatus
          ? _value.getCoinStatus
          : getCoinStatus // ignore: cast_nullable_to_non_nullable
              as FormzSubmissionStatus,
      coinList: freezed == coinList
          ? _value.coinList
          : coinList // ignore: cast_nullable_to_non_nullable
              as List<Coin>?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      cryptoSearchString: freezed == cryptoSearchString
          ? _value.cryptoSearchString
          : cryptoSearchString // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CoinStateImplCopyWith<$Res>
    implements $CoinStateCopyWith<$Res> {
  factory _$$CoinStateImplCopyWith(
          _$CoinStateImpl value, $Res Function(_$CoinStateImpl) then) =
      __$$CoinStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FormzSubmissionStatus getCoinStatus,
      List<Coin>? coinList,
      String? errorMessage,
      String? cryptoSearchString});
}

/// @nodoc
class __$$CoinStateImplCopyWithImpl<$Res>
    extends _$CoinStateCopyWithImpl<$Res, _$CoinStateImpl>
    implements _$$CoinStateImplCopyWith<$Res> {
  __$$CoinStateImplCopyWithImpl(
      _$CoinStateImpl _value, $Res Function(_$CoinStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CoinState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? getCoinStatus = null,
    Object? coinList = freezed,
    Object? errorMessage = freezed,
    Object? cryptoSearchString = freezed,
  }) {
    return _then(_$CoinStateImpl(
      getCoinStatus: null == getCoinStatus
          ? _value.getCoinStatus
          : getCoinStatus // ignore: cast_nullable_to_non_nullable
              as FormzSubmissionStatus,
      coinList: freezed == coinList
          ? _value._coinList
          : coinList // ignore: cast_nullable_to_non_nullable
              as List<Coin>?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
      cryptoSearchString: freezed == cryptoSearchString
          ? _value.cryptoSearchString
          : cryptoSearchString // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$CoinStateImpl extends _CoinState {
  _$CoinStateImpl(
      {this.getCoinStatus = FormzSubmissionStatus.initial,
      final List<Coin>? coinList,
      this.errorMessage,
      this.cryptoSearchString})
      : _coinList = coinList,
        super._();

  @override
  @JsonKey()
  final FormzSubmissionStatus getCoinStatus;
  final List<Coin>? _coinList;
  @override
  List<Coin>? get coinList {
    final value = _coinList;
    if (value == null) return null;
    if (_coinList is EqualUnmodifiableListView) return _coinList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? errorMessage;
  @override
  final String? cryptoSearchString;

  @override
  String toString() {
    return 'CoinState(getCoinStatus: $getCoinStatus, coinList: $coinList, errorMessage: $errorMessage, cryptoSearchString: $cryptoSearchString)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CoinStateImpl &&
            (identical(other.getCoinStatus, getCoinStatus) ||
                other.getCoinStatus == getCoinStatus) &&
            const DeepCollectionEquality().equals(other._coinList, _coinList) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage) &&
            (identical(other.cryptoSearchString, cryptoSearchString) ||
                other.cryptoSearchString == cryptoSearchString));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      getCoinStatus,
      const DeepCollectionEquality().hash(_coinList),
      errorMessage,
      cryptoSearchString);

  /// Create a copy of CoinState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CoinStateImplCopyWith<_$CoinStateImpl> get copyWith =>
      __$$CoinStateImplCopyWithImpl<_$CoinStateImpl>(this, _$identity);
}

abstract class _CoinState extends CoinState {
  factory _CoinState(
      {final FormzSubmissionStatus getCoinStatus,
      final List<Coin>? coinList,
      final String? errorMessage,
      final String? cryptoSearchString}) = _$CoinStateImpl;
  _CoinState._() : super._();

  @override
  FormzSubmissionStatus get getCoinStatus;
  @override
  List<Coin>? get coinList;
  @override
  String? get errorMessage;
  @override
  String? get cryptoSearchString;

  /// Create a copy of CoinState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CoinStateImplCopyWith<_$CoinStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
